import * as fs from 'fs';



function defineAst(outputDir: string, base: string, types: Array<string>) {
    const path = `${outputDir}/${base}.ts`
    const ws = fs.createWriteStream(path);

    ws.write(`// This code was auto generated by GenerateAst.ts\n`);

    ws.write('import { Token } from "./Token"\n');
    ws.write('\n');
    ws.write(`abstract class ${base} {\n`);

    ws.write(`}`);

    ws.write(`\n`);

    for (const type of types) {        
        const className = type.split('-')[0].trim();
        const fields = type.split('-')[1].trim();        
        defineType(ws, base, className, fields);
    }
    ws.end();
}

function generateAst(): void {
    const args = process.argv.slice(2);

    if (args.length != 1) {
        console.error('Usage: generate_ast <output director>');
        process.exit(64);
    }

    const outputDir: string = args[0];
    defineAst(outputDir, "Expr", [
        "Binary - left: Expr, operator: Token, right: Expr",
        "Grouping - expression: Expr",
        "Literal - value: Object",
        "Unary - operator: Token, right: Expr"
    ]);
}

generateAst();

function defineType(ws: fs.WriteStream, base: string, className: string, fields: string): void {    
    // Split fields on comma to build props
    const fieldArr = fields.split(',');
    const props = fieldArr.map(f => {
        return {
            prop: f.split(':')[0].trim(),
            type: f.split(':')[1].trim(),
        }
    });
    // Class
    ws.write(`class ${className} extends ${base} {\n`);

    // Class Props
    props.forEach(({prop, type}) => ws.write(`    ${prop}: ${type};\n`));

    ws.write('\n');

    // Constructor
    ws.write(`    constructor(${fields}){\n`);
    ws.write(`        super();\n`);

    

    // add each prop to constructor
    props.forEach(({prop}) => ws.write(`        this.${prop} = ${prop};\n`));
    
    ws.write(`    }\n`);
    ws.write(`}\n`);

}
